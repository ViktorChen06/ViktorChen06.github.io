<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>相机镜头硬件选型--机器视觉</title>
      <link href="/2024/03/30/%E7%9B%B8%E6%9C%BA%E9%95%9C%E5%A4%B4%E7%A1%AC%E4%BB%B6%E9%80%89%E5%9E%8B/"/>
      <url>/2024/03/30/%E7%9B%B8%E6%9C%BA%E9%95%9C%E5%A4%B4%E7%A1%AC%E4%BB%B6%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="镜头成像原理"><a href="#镜头成像原理" class="headerlink" title="镜头成像原理"></a>镜头成像原理</h3><p>先来看一下透镜成像原理：</p><p><img src="https://xian-vforum.oss-cn-hangzhou.aliyuncs.com/2022-08-22_CAKRHnp84n_image.png"></p><p>根据这个关系。可以确认物距 u = 焦距f * (1/放大系数  + 1）</p><p>机器视觉硬件选型，要根据精度、视野范围、物距范围，来确认相机，镜头的选型。</p><h3 id="相机选型"><a href="#相机选型" class="headerlink" title="相机选型"></a>相机选型</h3><ul><li>案例: 精度要求0.01，视野范围 10*10mm, 物距150±50，快门无要求</li></ul><p>一般的，对硬件的选型都取1/3作为理论安全系数进行选型，但是需要考虑部分客观性因素，那么最好使用1/5进行保险的安全系数。</p><p>这里我们按照1/3理论值来计算单像素精度：0.01 / 3 mm=3.333μ 。</p><p>相机分辨率：视野/单像素精度  = 3000*3000（10mm=10000um  10000/3.333≈3000）</p><p>因此找到分辨率比较接近的一款即可</p><p><img src="https://img2.imgtp.com/2024/03/30/Gz9blOT8.png"></p><h3 id="镜头选型"><a href="#镜头选型" class="headerlink" title="镜头选型"></a>镜头选型</h3><p>放大系数i = 像元尺寸/单像素精度 = 1.85/3.333= 0.56（得出镜头的放大倍率要到0.56）</p><p>根据：物距 u = 焦距f * ( 1 / 放大系数  + 1）</p><p>推导： 焦距f = 物距 u / ( 1 / 放大系数  + 1） = 150 /（1 / 0.56 +1）= 53.8</p><p>最接近53.8 的，是50mm镜头。</p><p>实际物距：物距 u = 焦距f * ( 1 / 放大系数  + 1）= 50 *（1 / 0.56 +1）= 139mm</p><p>实际相距v = 放大系数 * 物距 u  = 0.56 * 139 = 77.84 ≈ 78</p><p>根据相机芯片靶面 &lt; 镜头像面尺寸（也可理解位镜头靶面），则镜头像面尺寸参数要大于1/1.7’’</p><p>至此，我们获得了镜头的焦距、像面尺寸的参数，可以确定的是，我们需要使用50mm焦距的镜头，并且靶面要大于1/1.7’’；</p><p>然后，我们可以根据镜头硬件的MTF参数表，计算有效分辨率，例如：MVL-MF5028M-8MP这款镜头，MTF图显示大于0.3 线对大于160 ，有效分辨率500/160 = 3.125μ。</p><p><img src="https://xian-vforum.oss-cn-hangzhou.aliyuncs.com/2022-08-22_Uz4jCQJTTy_image.png"></p><p>MTF曲线图，不同颜色代表中心及周边不同的视场（或称像圈大小），每种颜色会有两条曲线，分别代表子午像（T）和弧矢像（S）。不难看出，MTF曲线与横、纵坐标围成的面积越大，代表镜头成像性能越好；不同颜色曲线越接近，代表视场中心和周边成像一致性越好；S与T越接近，代表不同方向的成像越一致。</p><p>关于镜头的解析力，也就是镜头型号后的xMP参数，一般默认选择相机分辨率的1/2，即：这里相机我们选择CU120这款，分辨率是1200w的，那么选型时选择600W以上的镜头就好（600w是镜头最小分辨率）。</p><p>同时也可参照MTF图进行精度计算，计算在0.3时以上时，其有效分辨率是否达到单像素精度的要求；</p><h3 id="硬件参数含义"><a href="#硬件参数含义" class="headerlink" title="硬件参数含义"></a>硬件参数含义</h3><ul><li>相机参数</li></ul><p>靶面尺寸：就是芯片尺寸，就是分辨率*像元尺寸。 同样的分辨率，像元尺寸越大，成像质量越好。价格越贵。</p><p>帧率：主要与分辨率 和 通讯接口相关， 同样的通讯接口， 分辨率越高，帧率越低。 提高帧率，要么降低分辨率，要么更换更快的通讯接口；同样的分辨率，U口的最大工作帧率要大于网口相机的。</p><p>镜头接口：最常用的的C接口，选镜头的时候，接口一定要对上。</p><p>快门方式：全局，卷帘。 全局支持飞拍。全局比卷帘贵。</p><p>靶面尺寸：就是芯片尺寸，就是分辨率*像元尺寸。 同样的分辨率，像元尺寸越大，成像质量越好。价格越贵。例如：CU120这款，分辨率是4024 × 3036，像元尺寸1.85 μm × 1.85 μm，则芯片尺寸 = （4024 * 1.85）  * （3026 * 1.85 ） = 7.4 *  5.6 mm</p><ul><li>镜头参数</li></ul><p>靶面尺寸：镜头靶面尺寸一定要大于相机的芯片靶面尺寸。</p><p>焦距：影响物距。同样视野下，并聚焦，焦距越大，物距越远；焦距和物距成正比关系 </p><p>焦距f ＝ WD（物距） × 相机芯片尺寸( h or v) / FOV视场( H or V)</p><p>光圈：光圈越大，支持越短的曝光时间。 光圈越小，景深越大。 镜头最佳成像质量光圈，一般在最大光圈，回缩一点的位置。比如F2.4光圈镜头，最佳成像质量就是2.2-2 的位置。（主观看法，没有试验依据）</p><p>镜头接口：要与相机接口一致，常用C口接口。</p><p>线对：0.3以上的线对才有意义。 比如200线对，就是 1mm范围内，有200对黑白相间的线条。  白色线条成像灰度是 GW， 黑色线条成像灰度是GB（参考MTF曲线图）</p><p>计算：r = GW-GB/GW+GB </p><p>r&gt;0.3以上    </p><p>比如： GW = 170， GB= 80   </p><p> r = 170-80/170+80 = 0.36  </p><h3 id="海康视觉硬件选型"><a href="#海康视觉硬件选型" class="headerlink" title="海康视觉硬件选型"></a>海康视觉硬件选型</h3><p>可以前往海康机器人官网 进行硬件选型，根据指示和参数进行填写，即可获取符合需求的镜头型号</p><p><a href="https://www.hikrobotics.com/cn/machinevision/visionproduct?typeId=40&amp;id=247">https://www.hikrobotics.com/cn/machinevision/visionproduct?typeId=40&amp;id=247</a></p><p><img src="https://img2.imgtp.com/2024/03/30/oOaTnbO4.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VM文档--Vision Master</title>
      <link href="/2024/03/23/pdf/"/>
      <url>/2024/03/23/pdf/</url>
      
        <content type="html"><![CDATA[<!-- <div class="row">    <embed src="./pdf.pdf" width="100%" height="550" type="application/pdf"></div> --><!-- <div class="row">    <embed src="https://pinfo.hikrobotics.com/hkws/unzip/20231101163730_26101_doc/index.html" width="100%" height="550" type="application/pdf"></div> --><p>海康机器人Vision Master软件技术手册，可下载至本地进行查阅</p><iframe src="https://pinfo.hikrobotics.com/hkws/unzip/20231101163730_26101_doc/index.html" style="width:100%; height:650px;"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> Vision Master </tag>
            
            <tag> 技术手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点抓取--Vision Master</title>
      <link href="/2024/03/23/%E5%8D%95%E7%82%B9%E6%8A%93%E5%8F%96/"/>
      <url>/2024/03/23/%E5%8D%95%E7%82%B9%E6%8A%93%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>机器视觉中常常需要使用工业相机进行手眼标定，让机器获取视觉算法的能力；手眼标定是指通过校准机器人手部与其视觉系统之间的关系，以确保机器能够准确地定位和操作目标。在手眼标定过程中，机器人手部的位置和姿态会与相机拍摄到的物体特征进行对应，从而建立二者之间的准确关联关系。</p><p>通过手眼标定，机器可以根据视觉系统提供的信息，精准地获取目标的位置和姿态，实现精准抓取、放置、定位等操作。手眼标定在工业自动化、机器人操作、计算机视觉等领域都有广泛的应用。</p><p>手眼标定是一项重要的工作，可以确保机器人与视觉系统协同工作时的精准性和准确性。本片文章将会从基础的单相机标定抓取进行展开，聊聊在Vision Master中如何完成简单的手眼标定抓取项目。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>面对定位项目首先需要的，是对项目的精度做数据考量，机构的执行误差、对位的项目公差、视觉系统的视觉精度误差，都是我们在开展这项工作前应当首要考虑到的，对于定位项目来说项目的定位精度应当是由以下三个部分组合而成：</p><ul><li>定位精度 = 机构精度（1/3）+ 运动精度（1/3）+ 视觉精度（1/3）</li></ul><p>对于视觉精度部分，定位项目中引起精度误差的因素有：标定误差、图像算法处理误差、坐标转换误差。为了达到视觉精度要求，常常要求视觉的单像素精度为视觉精度的1/3。</p><ul><li>例如：某个项目现阶段需要做到±0.12mm的精度，项目是否可行呢？</li></ul><p>那么首先我们得考虑，定位物品的刚性强度，如果是柔软的材料，那肯定是没办法做的，材料刚性越柔软，其定位精度越差（形变必然引起误差）。</p><p>此次，我们要考虑材料的大小，视觉中一个重要的准则是：视野越大，精度越差，视野越小，精度越高，对于一款较大的产品，必然视野也得相对应做大，那么也在一定程度上拖垮了视觉的精度。</p><p>如果材料和视野都不成大问题，那么此时视觉的精度就占据了整个项目精度的1/3，也就是0.04mm，再来还要考虑成像上，边缘位置还需要再考虑过渡带，此时单像素精度就得做到视觉精度的1/3，也就是0.04*（1/3）= 0.0133mm/pixel。</p><p>只有完成以上的准备工作后，才能进行后续的算法应用工作。</p><h3 id="标定工作"><a href="#标定工作" class="headerlink" title="标定工作"></a>标定工作</h3><p>标定目的：把图像坐标和现实的物理坐标统一起来，计算两套坐标的坐标映射关系，根据应用场景，可以将其分为末端执行器共轴与不共轴两种项目场景，那么在Vision Master（以下统一称作VM）中则可以对应使用平移标定以及平移旋转标定两条不同的路线。</p><p><img src="https://img2.imgtp.com/2024/03/23/sESkz8JS.png"></p><p>平移标定，一般使用9点标定，平移旋转标定，则是在此基础上引入N点的旋转坐标标定（通常为3点旋转标定）</p><p><img src="https://img2.imgtp.com/2024/03/23/t7moEjFI.png"></p><p><img src="https://img2.imgtp.com/2024/03/23/0t7kLXxZ.png"></p><p>在VM中，使用平移旋转标定算法模块，通过记录相机与机械臂的9个坐标点，可以自动生成一份标定数据文件，后续的单点对位模块利用此坐标映射文件，就能够通过像素特征映射获取到现实物理坐标，从而实现手眼标定的功能。</p><p><img src="https://img2.imgtp.com/2024/03/23/gsO8rR7D.png"></p><p>平移像素平均误差和旋转像素平均误差：根据实际精度要求判断，一般建议在一个像素以内。<br>角度旋转一致性：表示图像坐标系与机械手坐标系的旋转一致性，1 表示旋转一致，-1 表示旋转方向相反，需旋转机构查看旋转一致性是否判断准确。</p><h3 id="示教工作"><a href="#示教工作" class="headerlink" title="示教工作"></a>示教工作</h3><p>示教目的：通过示教建立目标检测物的基准像素坐标和物理坐标之间的关系；引导机械手以基准姿态抓住物料，并记录此时机械手坐标，然后回拍照位记录此时的图像特征点；实际生产时以此时图像特征点作为基准，将生产时图像特征点和基准图像特征点转到物理坐标系计算偏差。</p><p><img src="https://img2.imgtp.com/2024/03/23/mVkrdWJD.png"></p><h3 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h3><p>完成前面的标定以及示教工作，即可做最后的测试。</p><p>生产拍照位坐标为示教拍照位坐标，可产生 X/Y 偏移(最终偏差需在单点抓取偏差的基础上加上拍照位变化量)，但拍照姿态（相机旋转角度）必须保持不变；生产拍照位与标定时的工作距离必须保持不变。</p><p><img src="https://img2.imgtp.com/2024/03/23/CSVE50Xj.png"></p><p>在单点抓取模块中输入图像的特征点数据信息，以及机构的物理坐标，拍照时（第五点）的物理坐标，加载标定文件，完成单点抓取模块的配置工作。</p><p>模块结果分为相对坐标及绝对坐标，绝对坐标则为机构抓取的位置。使用格式化模块订阅单点抓取模块输出的偏差值/绝对坐标，然后使用发送数据模块将结果发送给机械手，机械手按照绝对坐标可实现引导定位。</p><p><img src="https://img2.imgtp.com/2024/03/23/Gesuwml3.png"></p><ul><li>详细教学：<a href="https://www.v-club.com/vCollage/vCollageDetail/219">https://www.v-club.com/vCollage/vCollageDetail/219</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vision Master </tag>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建(二)--Matery主题配置</title>
      <link href="/2023/04/30/Matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/04/30/Matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>前面为大家介绍了博客的基本框架搭建:<a href="https://viktorchen06.github.io/2023/04/27/Hexo%E6%90%AD%E5%BB%BA/">【Hexo搭建(一)】</a></p><p>下面让我们接着上一篇文章挖下的坑，把博客主题更换为Matery主题吧！</p><p>Matery主题是由blinkfox开源的一款响应式主题，其优秀的交互方式以及内置多种优秀的交互功能，深受极客的喜爱</p><h3 id="Matery-主题下载"><a href="#Matery-主题下载" class="headerlink" title="Matery 主题下载"></a>Matery 主题下载</h3><p>打开你的博客文件夹，找到<code>themes</code>文件，打开<code>Git Bash</code>命令窗后输入 <del>（必须要把主题文件放在这个文件夹下喔）</del></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;blinkfox&#x2F;hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你也可以直接网页下载然后在<code>themes</code>文件夹下解压，<a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">主题下载链接</a></p><p>下载完成后在博客根目录的<code>_config.yml</code>文件中修改配置，把主题<code>theme</code>修改为<code>hexo-theme-matery</code>，应用主题</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: hexo-theme-matery<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>并把全局中的相关信息更改</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Sitetitle: 博客名称subtitle: &#39;subtitle&#39;description: &#39;个性签名&#39;keywords:author: &#39;作者名字&#39;language: &#39;zh-CN&#39;timezone: &#39;Asia&#x2F;Shanghai&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># URL## Set your site url here. For example, if you use GitHub Page, set url as &#39;https:&#x2F;&#x2F;username.github.io&#x2F;project&#39;url: &#39;你的博客域名，例如我的是：http:&#x2F;&#x2F;ViktorChen06.github.io&#39;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成以上配置后记得保存</p><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><p>在<code>hexoblog</code>文件下<code>Git Bash</code>，新建以下页面</p><ul><li><p>标签页面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page &quot;tags&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成后编辑新建的/source/tags/index.md文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: tagsdate: 2023-04-27 19:37:07type: &quot;tags&quot;layout: &quot;tags&quot;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的其它页面也是按照这个格式进行初始化配置，按照这个模板填入信息后保存即可</p></li><li><p>分类页面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page &quot;categories&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: categoriesdate: 2023-04-27 19:37:07type: &quot;categories&quot;layout: &quot;categories&quot;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关于页面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page &quot;about&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: aboutdate: 2023-04-27 19:37:07type: &quot;about&quot;layout: &quot;about&quot;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>留言板</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page &quot;contact&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: contactdate: 2023-04-27 19:37:07type: &quot;contact&quot;layout: &quot;contact&quot;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>友情链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page &quot;friends&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: friendsdate: 2023-04-27 19:37:07type: &quot;friends&quot;layout: &quot;friends&quot;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>为了让友情页面有数据，配置完友情链接这个页面后，在博客根目录下的source文件夹新建 _data 目录，并在_data目录新建一个friends.json文件，把一些网页链接填写配置，来让这个页面有链接可以跳转，配置示例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[&#123;    &quot;avatar&quot;: &quot;http:&#x2F;&#x2F;image.luokangyuan.com&#x2F;4027734.jpeg&quot;,    &quot;name&quot;: &quot;BlinkFox&quot;,    &quot;introduction&quot;: &quot;blinkfox闪烁之狐的博客&quot;,    &quot;url&quot;: &quot;http:&#x2F;&#x2F;blinkfox.com&quot;,    &quot;title&quot;: &quot;前往学习&quot;   &#125;, &#123;    &quot;avatar&quot;: &quot;http:&#x2F;&#x2F;image.luokangyuan.com&#x2F;4027734.jpeg&quot;,    &quot;name&quot;: &quot;Viktor&quot;,    &quot;introduction&quot;: &quot;Viktor的博客&quot;,    &quot;url&quot;: &quot;https:&#x2F;&#x2F;viktorchen06.github.io&#x2F;&quot;,    &quot;title&quot;: &quot;前往学习&quot;   &#125;]   # 你可以拓展开来，但一定要按照以上的格式进行填写# avatar：图标# name:标签名字# introduction：链接简介# url: 链接# title：按键上的描述<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成所有配置后别忘记保存，接着在根目录下<code>Git Bash</code>，直接使用hexo三件套： <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code>，然后在服务器中输入我们的本地主机，可以发现我们的主题已经更换啦</p><p>接着我们回到主题的_config.yml文件进行配置</p><p><strong>注意！！！是主题文件/themes/hexo-theme-matery路径下的_config.yml配置文件，而不是全局根目录下的那个配置文件喔</strong></p><p>配置文件内有着读者大量的中文备注，你可以对着说明进行修改，并没有什么特别困难的，如果有需要的话后面再出一篇配置相关的帖子 <del>又给自己挖坑了（新建文件夹）</del></p><p>Waline评论系统也已完成搭建，可在我的博客找到相关的文章：<a href="https://viktorchen06.github.io/2023/04/30/%E7%94%A8Waline-Vercel%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/">【用Waline+Vercel搭建评论系统】</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello Hexo </tag>
            
            <tag> Matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Waline+Vercel搭建评论系统</title>
      <link href="/2023/04/30/%E7%94%A8Waline-Vercel%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/04/30/%E7%94%A8Waline-Vercel%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>博客搭建工作仍在进行，总感觉少了点什么，在参考其它大佬的个人博客后，发现很多都开通了留言板的评论功能，于是又在网上找了一堆重复的帖</p><p>多数文章写的是使用<code>Valine</code>，但是在自己使用的过程中发现，在配置项中<code>LeanCloud</code>的<code>appKey</code>和<code>appID</code>是直接在配置文件中直接粘贴上去的，那在页面源码那不就直接可以被人找到这两个值了？</p><p>正在头疼之际翻到了这篇文章：<a href="https://hin.cool/posts/waline.html">https://hin.cool/posts/waline.html</a></p><p>确实，使用<code>Valine</code>确实会带来上面猜想的问题，博主的文章也为我带来的一个全新的思路：换用<code>Waline</code>评论系统</p><p>一方面<code>Waline</code>的配置与<code>Valine</code>相差不多，但<code>Waline</code>相对来说会更加安全；这里可以为各位列一张表，让各位自主参考选择合适自己的评论系统</p><table><thead><tr><th>评论系统</th><th align="center">安全性</th><th align="center">Markdown</th><th align="center">便捷性</th></tr></thead><tbody><tr><td>Valine</td><td align="center">否</td><td align="center">支持</td><td align="center">是</td></tr><tr><td>Waline</td><td align="center">是</td><td align="center">支持</td><td align="center">是</td></tr><tr><td>Gitalk</td><td align="center">否</td><td align="center">支持</td><td align="center">否</td></tr><tr><td>hypercomments</td><td align="center">否</td><td align="center">不支持</td><td align="center">否</td></tr></tbody></table><p>综合下来看还是感觉<code>Waline</code>相对更加适合一些</p><h3 id="LeanCloud"><a href="#LeanCloud" class="headerlink" title="LeanCloud"></a>LeanCloud</h3><p>使用LeanCloud主要的目的，是将网页用户的评论保存下来，相当于一个云存储，管理人员也可以很方便地对数据进行操作，能够节省很多开发步骤</p><ul><li><p>LeanCloud注册</p><p>  大部分刚开始搭建个人博客的人都是托管在<code>GitHub</code>上，没有对域名进行备案的情况下建议大家在注册时将<code>LeanCloud</code>改为国际版，并创建应用<br>  <img src="https://pic4.zhimg.com/80/v2-23da7044646505360c3fd5ba69e93b7b_720w.webp"></p><p>   输入应用名称，点击创建 <del>(选择开发版，将白嫖进行到底)</del><br>  <img src="https://guanqr.com/images/waline-0.png"></p><p>  创建应用后前往控制台 –&gt; 设置 –&gt; 应用凭证，这三串码很重要，后面会用到。由于使用<code>Valine</code>会在网页后台直接暴露这几个码，而<code>Waline</code>通过其它配置手段配置后不会，因此我没有选择使用<code>Valine</code></p><p>  <img src="https://waline.js.org/assets/leancloud-2-4cc69975.png"></p></li></ul><h3 id="Vercel服务端"><a href="#Vercel服务端" class="headerlink" title="Vercel服务端"></a>Vercel服务端</h3><p>首先前往<a href="https://vercel.com/new">Vercel</a>：跳转到<code>Vercel</code>进行服务端的配置部署（未登录的请使用<code>GitHub</code>账户进行登录，后<code>Vercel</code>会在你的仓库上新建一个服务）</p><p>输入一个新的仓库项目名字，并创建，此时<code>Vercel</code>会基于<code>Waline</code>模板帮你新建并初始化一个仓库项目，骚等一两分钟即可<br><img src="https://waline.js.org/assets/vercel-1-4e9dd7aa.png"></p><p>等到网页放烟花庆祝时，证明模板已经部署完成，点击<code>Go to Dashboard</code>跳转到这个项目的控制台<br><img src="https://waline.js.org/assets/vercel-4-f7f4c12b.png"></p><p>点击顶部的 <code>Settings</code> - <code>Environment Variables</code> 进入环境变量配置页，并配置三个环境变量 <code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code> 。它们的值分别对应上一步在 <code>LeanCloud</code> 中获得的 <code>APP ID</code>, <code>APP KEY</code>, <code>Master Key</code>。</p><p>如果配置弄不懂的话可以观看这个视频：<a href="https://www.bilibili.com/video/BV1Ft4y1A73f/?share_source=copy_web&vd_source=da91d3ca78a47453aa7098e6dc9f6ca9">【使用Vercel简单地部署Waline评论系统】</a><br><img src="https://waline.js.org/assets/vercel-5-3a5de7f0.png"></p><p>配置完环境变量后，点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署，让输入的环境变量生效。<br><img src="https://waline.js.org/assets/vercel-6-c1af01b1.png"></p><p>此时会跳转到 <code>Overview</code> 界面开始部署，等待片刻后 <code>STATUS</code> 会变成 <code>Ready</code>。此时请点击 <code>Visit</code> ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。<br><img src="https://waline.js.org/assets/vercel-7-2478902b.png"></p><p>此时你会发现，点击<code>Visit</code>后网页似乎加载不出来亦或者无法访问，这是因为<code>Vercel</code>在国内似乎被科学了（悲） <del>（DNS污染）</del>  于是你刚才部署的项目无法通过国内的使用，那我怎么使用评论啊！！？？憋急，接着往下看</p><h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>那既然<code>vercel.app</code>的网站无法正常访问，干脆搞个子域名做跳转吧，国内你可以选择阿里云或者腾讯云之类的服务商购买域名，但是考虑到国内购买域名需要备案等乱七八糟的，备案完别人还能在域名备案查询网站找出你的个人信息，就十分反感。</p><p>因此，在这里推荐各位可以使用<code>NameSilo</code>购买域名，我这里使用了一位博主的优惠码<code>asns2020</code>，实际上域名一年也只花了7块钱而已</p><ul><li><p>NameSilo 域名购买流程</p><p>  NameSilo官网链接：<a href="https://www.namesilo.com/">【NameSilo官网】</a></p><p>  关于域名购买的流程比较繁琐，直接附上教程链接：<a href="https://zhuanlan.zhihu.com/p/33921436">【Namesilo 域名购买及使用教程】</a></p><p>  后续文章直接开始<code>DNS解析</code>的操作</p></li><li><p>域名解析</p><p>回到我们的<code>Vercel</code>，点击顶部的 <code>Settings</code> - <code>Domains</code> 进入域名配置页，输入我们刚购买的域名并点击<code>Add</code></p><p>此时这个域名下面将弹出配置信息，提示你这个域名需要<code>DNS</code>解析<code>Vercel</code>提供的值，比如这串 类型为 <code>A</code> 的 <code>Value</code>值为<code>76.xx.xx.xx</code> 的<br><img src="https://img.kuizuo.cn/image-20220511171359148.png"></p><p>将其复制下来，回到<code>NameSilo</code>进行<code>DNS解析</code>，首先点击上方的Change Nameservers更改域名服务器，更换Name Server为<code>Vercel</code>提供的两个<code>server地址</code>，再点击图中的小蓝球编辑<code>DNS</code><br><img src="https://pic3.zhimg.com/80/v2-d685f9aa06f1c2668f0fdcf9c867d2b2_720w.webp"></p><p>在设置前，<strong>首先把自带的五条默认记录全部删除（DELETE）！！！</strong><br>域名解析可以添加两条 A 记录，或者使用 A + CNAME 的组合。<br>点击 “Add/Edit a Resource Record” 栏中的 A，依次添加两条 A 记录，将域名指向主机 IP，以我为例使用了A + CNAME 的组合，设置如下：</p></li><li><p>第一条：HOSTNAME：空，TYPE: A, 76.xx.xx.xx：，TTL：默认可不改；</p></li><li><p>第二条：HOSTNAME：www，TYPE: CNAME，cname.vercel-dns.com：，TTL：默认可不改。 </p></li></ul><p>编辑完一条后点击<code>submit</code>提交，设置完<code>DNS</code>就能访问回我那个被挂掉的服务端了吗？<del>我知道你很急，但你先别急</del> </p><p><code>DNS</code>配置以及<code>NameServer</code>一般需要<code>15~30分钟</code>才能生效，等改动生效后，我们再用购买的域名去访问，就能通过自己的域名来访问评论系统啦</p><p>这里附上几篇在NameSilo进行DNS解析的文章：</p><p><a href="https://zhuanlan.zhihu.com/p/404334251">【萌新建站教程（四）namesilo域名解析设置】</a><br><a href="https://blog.csdn.net/qq_19363379/article/details/108119140">【搭建个人网站（2）：Github和Vercel建站以及配置DNS】</a><br><a href="https://blog.naibabiji.com/tutorial/namesilo-yu-ming-jie-xi-geng-huan-dns-jiao-cheng.html">【NameSilo域名解析和DNS服务器修改教程】</a></p><p>切记！在评论框点击登录按键，并注册一个账号进行留言，第一个账号是这个评论系统的管理员，你可以在<code>LeanCloud</code>的<code>结构化数据</code>中看到相关信息以及他人的留言内容 <del>（不好的留言我会删 bushi）</del></p><p>记得把你的主题下的<code>_config.yml</code>里的<code>Waline</code>配置项打开，别配了半天啥博客反应都没有，我的博客留言板已开通，欢迎各位留言，请各位文明发言</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello Hexo </tag>
            
            <tag> Waline </tag>
            
            <tag> Vercel </tag>
            
            <tag> NameSilo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#/.NET-泛型</title>
      <link href="/2023/04/28/C-NET-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/04/28/C-NET-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是泛型-Generic"><a href="#什么是泛型-Generic" class="headerlink" title="什么是泛型 Generic"></a>什么是泛型 Generic</h3><ul><li><p>简单的来讲，泛型相当于模板，它允许您编写一个可以与任何数据类型一起工作的类或方法（说白了就是允许你根据模板制定自己需要的数据类型方法、类、接口）</p></li><li><p>使用泛型是一种增强程序功能的技术，有助于您最大限度地重用代码、保护类型的安全以及提高性能</p></li><li><p>标志就是以<code>&lt;T&gt;</code>为占位符的占位委托</p></li></ul><p><strong>注意：泛型类型要避免使用<code>object</code>类型，避免反复装箱拆箱的操作，会带来性能损耗</strong></p><h3 id="泛型的优点和原理"><a href="#泛型的优点和原理" class="headerlink" title="泛型的优点和原理"></a>泛型的优点和原理</h3><ul><li>最大的特点就是“通用”，<code>C#</code>在编译器下【这里还没确定泛型的确定类型，但是有<code>T</code>（机器码内以 ` 反单引号）作为一个占位符】生成/运行的时候会生成一个<code>DLL/EXE</code>文件，然后通过<code>CLR</code>环境【这一步确定泛型的具体类型 】进行二次编译，生成机器码（假如直接生成机器码的话在跨环境的情况下，机器内部硬件不同就可能不能执行，这样的话跨平台能力就会比较差）</li></ul><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><ul><li>规定泛型数据的类型，防止什么类型的数据都输入进来，写法：<code>where</code>；<br>约束的类型：<br>– <code>new()</code> 约束–表示只接受带有一个无参数的构造函数<br>– <code>struct</code> 值类型约束：（值类型：结构体<code>struct</code>/<code>int</code>、<code>double</code>、<code>bool</code>和<code>枚举</code>。引用类型：<code>类</code>，<code>接口</code>，<code>委托</code>、<code>object</code>、<code>字符串</code>）<br>– <code>class</code> 引用类型约束<br>– 自定义类型约束 <code>where T : student</code><br>– 多类型约束 <code>where T : class,new()</code>  【<code>new()</code>约束一定要写在多类型约束的最后面】，但是参数约束不能有冲突，比如值类型和引用类型不能同时存在。</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public static void Show&lt;T&gt;(T t1) where T:new()  &#x2F;&#x2F;只接收可以实例化的类，比如接口就不行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面来写一个泛型的小demo，来更好的观测不同数据类型作为类型约束时，数据输出的差异，记得在测试时打上断点，方便调试</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace GenericTestProject&#123;    public class GenericTestClass&lt;T&gt; &#123;        &#x2F;&#x2F;定义私有域数组变量，并且泛型定义数组类型        private T[] genericArray;        &#x2F;&#x2F;使用构造方法对类中的属性进行初始化        public GenericTestClass(int size)&#123;            &#x2F;&#x2F;初始化创建出泛型对应的数组，包括类型和长度            &#x2F;&#x2F;例如 T 为int 时，下面语句就是：genericArray &#x3D; new int[size + 1];            genericArray &#x3D; new T[size + 1];        &#125;        &#x2F;&#x2F;设置数组的值        public void setItem(int index, T value) &#123;            genericArray[index] &#x3D; value;        &#125;        &#x2F;&#x2F;获取数组的值        public T getItem(int index) &#123;            return genericArray[index];        &#125;    &#125;    class Program    &#123;        &#x2F;&#x2F;程序入口        public static void Main(string[] args)&#123;            &#x2F;&#x2F;测试当泛型数据为int类型时的情况            GenericTestClass&lt;int&gt; genTest &#x3D; new GenericTestClass&lt;int&gt;(5);            for (int i &#x3D; 0; i &lt; 5; i++) &#123;                genTest.setItem(i, i + 1);            &#125;            for (int j &#x3D; 0; j &lt; 5; j++) &#123;                Console.Write(genTest.getItem(j) + &quot; &quot;);            &#125;            &#x2F;&#x2F;下面测试使用char作为泛型类型数据时的情况            Console.WriteLine(&quot;\n----------------------------&quot;);            GenericTestClass&lt;char&gt; genTest2 &#x3D; new GenericTestClass&lt;char&gt;(5);            for (int a &#x3D; 0; a &lt; 5; a++) &#123;                genTest2.setItem(a, (char)(a + 96));            &#125;            for (int b &#x3D; 0; b &lt; 5; b++) &#123;                Console.Write(genTest2.getItem(b) + &quot; &quot;);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型的其它使用"><a href="#泛型的其它使用" class="headerlink" title="泛型的其它使用"></a>泛型的其它使用</h3><p><strong>泛型字典Dictionary&lt;K,V&gt; ,键/值对，是成对存在的</strong></p><ul><li>泛型字典内部有自带的方法（Add）</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Dictionary&lt;int, string&gt; dic &#x3D; new Dictionary&lt;int,string&gt;();&#x2F;&#x2F;dic.Add(1,&quot;C#&quot;);dic.Add(1,&quot;C++&quot;);dic.Add(1,&quot;C&quot;);foreach(var item in dic)&#123;Console.WriteLine(item.Key.ToString()+&quot; &quot; + item.Value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ContainsValue，数据匹配；Remove，根据键位进行删除</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">bool isContains &#x3D; dic.ContainsValue(&quot;C#&quot;); dic.Remove(1); &#x2F;&#x2F;根据键位匹配，删除了字典内对应的数据值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="泛型自定义"><a href="#泛型自定义" class="headerlink" title="泛型自定义"></a>泛型自定义</h3><ul><li>举例：操作数据库，读取数据时，每个表返回数据格式都不同。使用泛型自定义的话可以封装这样用不同的格式进行接收！通用的函数方法可以使代码的复用率提高，减少冗余代码</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 自定义泛型类，这样可以提高代码复用    &#x2F;&#x2F;&#x2F; 假如是SQL helper类提取数据库内不同数据时，可以使用    &#x2F;&#x2F;&#x2F; 一段代码块适配不同的数据然后调取配置&#x2F;&#x2F;&#x2F; 使用占位符T表示待定数据类型，通过实例化传递类型数据定义泛型类的数据类型，泛型定义符号可以定义多个    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;&lt;&#x2F;typeparam&gt;    class myGeneric&lt;T&gt;    &#123;        private T dataTest;        &#x2F;&#x2F;构造函数        public myGeneric(T dataTest)        &#123;            this.dataTest &#x3D; dataTest;        &#125;        public void getDataTest() &#123;            Console.WriteLine(dataTest);        &#125;    &#125;    ........        public static void Main(string[] args)&#123;            myGeneric&lt;int&gt; mg &#x3D; new myGeneric&lt;int&gt;(111);            mg.getDataTest();  myGeneric&lt;string&gt; mg2 &#x3D; new myGeneric&lt;string&gt;(&quot;abc&quot;);            mg2.getDataTest();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>使用泛型之后，数据库的crud就不再需要写这么多个方法就能通用</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void Show&lt;T&gt;(T showSomething)&#123;Console.WriteLine(showSomething.ToString());&#125;...... show(&quot;展示泛型方法&quot;)；    show(101010);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public static void Main(string[] args)&#123;&#x2F;&#x2F;实例化两个对象实例    ChineseHuman ch &#x3D; new ChineseHuman() &#123; HumanName &#x3D; &quot;小明&quot; &#125;;    BirdClass bc &#x3D; new BirdClass() &#123;AnimalType &#x3D; &quot;鹦鹉&quot; &#125;;   &#x2F;&#x2F;调用函数，对泛型类型进行定义，并且将实例作为实参传入    &#x2F;&#x2F;可以发现的是,泛型定义类型已经被方法体内的泛型约束给限制了,  &#x2F;&#x2F;无法定义为其它类型的泛型定义    &#x2F;&#x2F;泛型定义必须要与展示方法show的where约束类型相同,并且传参也要与泛型类型相同    FunClass.ShowAnimal&lt;AnimalClass&gt;(bc);    FunClass.ShowHuman&lt;ChineseHuman&gt;(ch);&#125;&#x2F;&#x2F;展示方法public class FunClass &#123;  &#x2F;&#x2F;泛型约束where        public static void ShowHuman&lt;T&gt;(T Typedef) where T : HumanClass &#123;           Console.WriteLine($&quot;这个人名字是&#123;Typedef.HumanName&#125;&quot;);       &#125;       public static void ShowAnimal&lt;T&gt;(T Typedef) where T : AnimalClass&#123;           Console.WriteLine($&quot;这只鸟的种类是&#123;Typedef.AnimalType&#125;&quot;);       &#125;&#125;... 继承public class BirdClass : AnimalClass&#123;      public string BirdName &#123; get; set; &#125;&#125;...继承public class ChineseHuman : HumanClass&#123;      public string Cname &#123; get; set; &#125;&#125;...父类public class HumanClass&#123;      public string HumanName &#123; get; set; &#125;&#125;...父类public class AnimalClass&#123;      public string AnimalType &#123; get; set; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>那么话说回来，使用泛型对于我这个菜鸡来说有什么好处呢？好处就是，从前刚接触代码都是有一个需求就写一个，现在使用泛型我可以把一些重复的、近似度高的代码复用起来，通过泛型这个写法最大程度地复用代码，同时泛型可以在一些特殊场景让我的代码具备一定的安全性。<br>回到我的专业领域，在嵌入式中，开发芯片的内存可谓是寸土寸金，如果不将可复用的代码最大程度地利用起来，转而为每个功能都写上一个功能函数，那ROM岂不是被大量的浪费掉了，这只是个人比较片面的看法，希望对你有所帮助</p>]]></content>
      
      
      
        <tags>
            
            <tag> C#/.NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建(一)</title>
      <link href="/2023/04/27/Hexo%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/04/27/Hexo%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>我的个人技术博客终于搭建好啦！！！<del>没想到搭建一个blog只需要Ctrl C + Ctrl V就能完成（高级CV工程师了属于是）</del></p><p>废话不多说，来简单介绍一下博客的搭建过程以及遇到的一些坑</p><p>本网站使用<code>Hexo</code>框架进行搭建，<code>Hexo</code>是一款高效简洁的博客框架，通过配置文件的修改以及第三方插件的安装可在短时间内搭建出属于自己的博客网站</p><p><code>Hexo</code>框架可将<code>MarkDown</code>格式的文件进行解析渲染，从而完成文章的输出</p><p>在准备搭建自己的<code>blog</code>之前，希望你的开发环境做好一下准备：</p><ul><li>前往 <del>全球最大的同性交友网站（bushi）</del> GitHub注册一个自己的账号，后期生成的静态<code>blog</code>将托管在你的<code>GitHub</code>仓库中</li><li>下载<code>Visual Studio Code</code> 和 <code>Git</code>版本管理器，框架安装完成后很多配置文件需要在编译器中完成修改，<code>vscode</code>是个人用的比较舒服的一款编译器，后期的<code>MarkDown</code>文章通过<code>vscode</code>编纂也会相对简单便捷一些；<code>Git</code>就不多说啦，很好用的版本管理器，后期文章写完也需要通过版本管理器上传至自己的仓库，必不可少</li><li>下载<code>Node.js</code>并配置环境，由于篇幅有限，这里奉上安装教程链接：<a href="https://blog.csdn.net/WHF__/article/details/129362462">https://blog.csdn.net/WHF__/article/details/129362462</a></li></ul><h3 id="Git-账户配置"><a href="#Git-账户配置" class="headerlink" title="Git 账户配置"></a>Git 账户配置</h3><p>安装完<code>Git</code>后并不能直接使用，需要先将自己的<code>GitHub</code>账号配置进来,在一个新的文件下右键<code>Git Bash</code>,弹出指令窗口后输入以下指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config --global user.name &quot;自己的GitHub用户名&quot;$ git config --global user.email &quot;自己的GitHub注册邮箱&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成自己的<code>SSH</code>密钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时在<code>C:\Users\xxxx\.ssh</code>文件路径中将<code>id_rsa.pub</code>密钥通过文本打开，复制下自己的公共密钥，在<code>GitHub</code>的<code>头像--&gt;Settings--&gt;SSH and GPG keys</code>中添加上公共密钥<code>SSH Keys</code></p><p><img src="https://pic1.zhimg.com/80/v2-72a3f22c080e99343c3cc4aabce10e3c_720w.webp"></p><p>回到<code>Git</code>,输入命令</p><pre class="line-numbers language-none"><code class="language-none">$ ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回为：<code>Hi 用户名！ You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><p>则说明配置已成功，如果不是该返回值，请检查自己的网络状况多试几次，毕竟这个网站….你懂的</p><h3 id="Node-js-安装检查"><a href="#Node-js-安装检查" class="headerlink" title="Node.js 安装检查"></a>Node.js 安装检查</h3><p>在正式开始<code>Hexo</code>框架安装前，在<code>cmd</code>中输入</p><pre class="line-numbers language-none"><code class="language-none">$ node -v$ npm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看是否有<code>node</code>和<code>npm</code>版本号返回，如果没有，请检查电脑的环境变量是否配置添加了<code>node</code>相关的环境变量</p><h3 id="Hexo-框架安装"><a href="#Hexo-框架安装" class="headerlink" title="Hexo 框架安装"></a>Hexo 框架安装</h3><p>千呼万唤，终于到我们的主角登场了，在准备好前面的步骤后，首先新建一个文件夹用来保存我们的静态<code>Blog</code>工程，尽量不要以中文的形式命名，后续的所有工程以及文章都会保存在这个工程文件夹中</p><p>进入文件夹，右键<code>Git Bash</code>,使用开始安装<code>Hexo</code></p><pre class="line-numbers language-none"><code class="language-none">$ curl -O https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;kjhuanhao&#x2F;hexo-script@master&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://3344701850-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlpfTEtpw-XHjloYx-t%2F-Llujyttm0BWO_RMRg-2%2F-LlukgEwkesx8NRKmBdo%2F2.png?alt=media&token=ec7c6fd6-108a-4161-a3d5-1a67438fa83d"></p><p>此时文件下会生成一个下载文件<code>install.sh</code></p><p>继续，在当前路径下输入指令</p><pre class="line-numbers language-none"><code class="language-none">$ source install.sh test_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://3344701850-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlpfTEtpw-XHjloYx-t%2F-Llul9Kdh1NJmVlnXuGd%2F-Llum1fgCUk0Unm0jlVo%2F3.png?alt=media&token=6a788601-ff5f-4f61-8862-7b179074e1c2"><br>(出现了版本号和成功的提示信息代表<code>node</code>配置成功)</p><p>输入指令开始安装<code>windows</code>环境下的<code>hexo</code>框架</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ source install.sh hexo_win<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://3344701850-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlpfTEtpw-XHjloYx-t%2F-LluplfJDETDQ1wIHNxR%2F-LlupnWqOZVWU6iL3uK9%2F5.png?alt=media&token=30690ad9-b4fb-4240-ad96-1ea7686d888c"></p><p>出现这个时，我们的任务就已经完成一半啦！</p><p>回到文件夹中，你会发现生成了一个叫<code>hexoblog</code>的文件夹，进入到该文件夹中，你可以使用<code>cd hexoblog</code>指令进入或者关闭<code>Git</code>窗口手动进入<code>hexoblog</code>重新<code>Git Bash</code>打开</p><p>来，现在试着在<code>Git</code>的命令窗口下输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://3344701850-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlpfTEtpw-XHjloYx-t%2F-LluplfJDETDQ1wIHNxR%2F-LluqmWs7L0rHAJhJkR-%2F6.png?alt=media&token=88e71510-22da-4c59-bd41-1d7bb2909436"></p><p>右键复制中间那串地址前往浏览器打开，<strong>千万不要用Ctrl+C复制！！！会把刚打开的本地服务器关掉的</strong></p><p><img src="https://3344701850-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlpfTEtpw-XHjloYx-t%2F-LluplfJDETDQ1wIHNxR%2F-LlurN1aku8F_ZGR35Av%2F7.png?alt=media&token=c9b96207-b162-43de-839b-1837d1241566"></p><p>可喜可贺，你已经成功通过Hexo框架搭建出<code>blog</code>的雏形啦，后面我们会使用<code>Matery</code>主题更换掉这个单调简单空 liao liao 的界面，敬请关注。<del>（新建文件夹）</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
